[2390. Removing Stars From a String](https://leetcode.com/problems/removing-stars-from-a-string/description/?envType=study-plan-v2&envId=leetcode-75)

## **üìå Problem Statement**  
Given a string `s` containing lowercase English letters and the `*` (star) character, remove all stars and their **closest non-star characters to the left**.  

Each `*` removes the nearest non-star character on its left, along with itself. The input guarantees that this operation is always possible.  

### **Example Walkthrough**
#### **Example 1**  
##### **Input:**  
```cpp
s = "leet**cod*e"
```
##### **Process:**  
- `'t'` is removed by the first `*` ‚Üí `"lee*cod*e"`
- `'e'` is removed by the second `*` ‚Üí `"lecod*e"`
- `'d'` is removed by the third `*` ‚Üí `"lecoe"`

##### **Output:**  
```cpp
"lecoe"
```

---

#### **Example 2**  
##### **Input:**  
```cpp
s = "erase*****"
```
##### **Process:**  
- `'e'`, `'r'`, `'a'`, `'s'`, `'e'` are all removed by five `*`
- **Final output is an empty string**  

##### **Output:**  
```cpp
""
```

---

## **üí° Optimized Approach (Using Stack)**
### **Key Observations**
- The `*` always removes the closest character to its **left**.
- The **stack data structure** is ideal here since:
  - **Push** non-star characters onto the stack.
  - **Pop** the top element when encountering a `*`.
  - The remaining elements in the stack form the final result.

---

## **Optimized C++ Solution**
```cpp
class Solution {
public:
    string removeStars(string s) {
        stack<char> st;
        string result;

        // Iterate over the string
        for (char c : s) {
            if (c != '*') {
                st.push(c);
            } else if (!st.empty()) {
                st.pop(); // Remove the closest non-star character
            }
        }

        // Build result from stack
        while (!st.empty()) {
            result.push_back(st.top());
            st.pop();
        }

        // Reverse to get correct order
        reverse(result.begin(), result.end());
        return result;
    }
};
```

---

## **üöÄ Optimized Approach (Using String as a Stack)**
Instead of using an explicit `stack<char>`, we can utilize a **string as a stack**, avoiding extra space.

### **Code Using String as Stack**
```cpp
class Solution {
public:
    string removeStars(string s) {
        string result;
        
        // Simulate a stack using string
        for (char c : s) {
            if (c != '*') {
                result.push_back(c); // Push character to the "stack"
            } else if (!result.empty()) {
                result.pop_back(); // Pop last added character
            }
        }

        return result; // No need to reverse
    }
};
```

---

## **üí° Complexity Analysis**
| Complexity  | Explanation |
|------------|------------|
| **Time Complexity** | **O(n)** ‚Üí We iterate over the string once and perform `push_back` / `pop_back` in **O(1)** time each. |
| **Space Complexity** | **O(n)** ‚Üí Stores the final result in a string. |

---

## **‚úÖ Edge Cases Considered**
### **1Ô∏è‚É£ String with No Stars**
```cpp
s = "abcdef"
```
‚úî Output: `"abcdef"` (No changes)

### **2Ô∏è‚É£ String Full of Stars**
```cpp
s = "******"
```
‚úî Output: `""` (Empty string)

### **3Ô∏è‚É£ Consecutive Stars**
```cpp
s = "a*b*c*d*"
```
‚úî Output: `""` (All characters are removed)

### **4Ô∏è‚É£ Star at the End**
```cpp
s = "abcde*"
```
‚úî Output: `"abcd"`

---

## **üí° Summary**
‚úÖ **Uses stack or string simulation to efficiently process removals**  
‚úÖ **Optimized solution with O(n) time complexity and O(n) space complexity**  
‚úÖ **Edge cases handled properly**